"**Getting Started with Focus.js**\n \n\nTo understand Focus.js' specificities we are going to build the age old tested example of a Todo list application. We will start by defining the structure of our application, we will need :\n\n* A single view called Todos.jsx\n* A Todo Model\n* A Todos Collection to sort through models\n* And last but not least a TodoBinder\n For the purpose of this example I will be using React as a template engine.\n Our view will need to represent a list of actions with a checkbox to mark them as done. It will also display an input field to display all tasks as done\n\n'''var Todos = React.createClass({\n\n    getInitialState: function() {\n        \n        return {\n            list: []\n        };\n        \n    },\n    render: function() {\n\n        var _this = this;\n\n        return <div className=\"todos\">\n\n            <input type=\"text\" ref=\"textInput\" className=\"add\"/><button>Add</button>\n            <ul>\n                {\n                    this.state.list.map(function(_todo, i) {\n                        return (<li> \n                            <input type=\"checkbox\" />\n                            <label> {_todo.text} </label>\n                            <button>Delete</button>\n                        </li>)\n                    })\n                }\n            </ul>\n            <button className=\"clear\"> Clear done </button>\n        </div>\n\n    }\n\n});'''\n\n We will then set up our model with a toggleDone method to switch from done to todo state :\n\n'''module.exports = Focus.Model('Todo', {\n    attributes: {\n        done: false\n    },\n\n    toggleDone: function() {\n        this.set(\"done\", !this.attributes.done);\n    }\n});'''\n\nWe then set up a basic Focus collection that will allow to sort through data and output our collection of models as json :\n\n'''module.exports = Focus.Collection({\n    model: \"Todo\"\n});'''\n\nWith all this set up we only need to build the communication between models/collections and the view. This is where Binders come in, they will attach behaviour to views. The fact that these methods live outside the view allows us to share them accross multiple views and encourages developpers to build view agnostic functions that will output data.\n\nOur simple todo list will allow the user to add tasks, delete tasks, check tasks as done and clear all done tasks. To do this we will set up the following Binder :\n\n'''var TodoModel = require('../models/Todo.js');\nvar TodosCollection = require('../collections/Todos.js');\n\nmodule.exports = Focus.Binder('Todo', {\n    init: function() {\n\n        var _this = this;\n        this.list = new TodosCollection();\n\n        Dispatcher.register('todoList:update', function() {\n            _this.setState({list: _this.list.toJSON() });\n        });\n\n    },\n\n    add: function(_text) {\n\n        this.list.push(\n            new TodoModel({\n                text: _text\n            })\n        );\n        Dispatcher.dispatch(\"todoList:update\");\n    },\n\n    taskDone: function(_id) {\n        this.list[_id].toggleDone();\n        Dispatcher.dispatch(\"todoList:update\");\n    },\n\n    delete: function(_id) {\n        this.list[_id].destroy();\n        this.list.splice(_id,1);\n        Dispatcher.dispatch(\"todoList:update\");\n    },\n\n    clearDone: function() {\n\n        this.list.deleteWhere('done', true);\n        Dispatcher.dispatch(\"todoList:update\");\n    }\n\n});\n'''\n\nAll that is left to do then is to use the binder from within our view, this is easily achieved using react by adding listeners directly to the JSX elements :\n\n'''var TodosBinder = require('../binders/TodoBinder.js');\n\nmodule.exports = React.createClass({\n\n    getInitialState: function() {\n\n        return {\n            list: []\n        };\n\n    },\n\n    componentDidMount: function() {\n\n        TodosBinder(this, ['add','delete','taskDone', 'clearDone']);\n\n    },\n\n    render: function() {\n\n        var _this = this;\n\n        return <div className=\"todos\">\n\n            <input type=\"text\" ref=\"textInput\" className=\"add\" onKeyUp={this.onKeyUp} /><button onClick={this.onAddClick}>Add</button>\n            <ul>\n                {\n                    this.state.list.map(function(_todo, i) {\n                        return (<li key={\"todo-\"+i}>\n                            <input type=\"checkbox\"\n                            onClick={_this.taskDone.bind(_this, i )} checked={_todo.done ? true : false} />\n                            <label> {_todo.text} </label>\n                            <button onClick={_this.delete.bind(_this, i)}>Delete</button>\n                        </li>)\n                    })\n                }\n            </ul>\n            <button className=\"clear\" onClick={_this.clearDone}> Clear done </button>\n        </div>\n\n    },\n\n    onKeyUp: function(e,a) {\n        if (e.which === 13) this.onAddClick();\n    },\n\n    onAddClick: function() {\n        var _value = this.refs.textInput.value;\n        if (_value.length>0)\n            this.add(_value);\n        this.refs.textInput.value= \"\";\n        this.refs.textInput.focus();\n    }\n\n});'''\n\nThis example shows how Focus.js implements a MVVM pattern by binding methods directly to views. These methods have no dependency on the view itself, they implement communication in an abstract way that should simplify maintenance.\n\n This example should give you basic understanding of the core concept behind Focus.js, it implements the Dispatcher which you can read more about in the documentation. Focus also gives you access to a simple router and a few helper functions to speed up your development and reduce your dependencies."